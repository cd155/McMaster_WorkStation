\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{MidTerm Review}
\author{Don Chen}
\date{\today}

\begin {document}

\maketitle
Exam on March 4th

\section{Softare Quality}
Lecture 4
\begin{itemize}
    \item Quality and price are two things.
    \item User Satisfaction = The Important Qualities are High $+$ Within Budget
    \item External qualities are visible to the user p7
    \item Internal qualities are visible to the developer
    \item Product qualities and Process qualities, p7
    \item Correctness: if it satisfies its requirements specification. p9
    \item Reliability: The software works most time, but fails in a small portion of time. p10
    \item Robustness: if it behaves reasonably even in unanticipated or exceptional situations. p11
    \item Performance(efficiency): related to external quality requirements for speed and storage. p15
    \item Usability: how easy a user can use the product. p16
    \item Verifiability: how easy it is to convince someone it is correct. p18
    \item Maintainability: how ease it is to modify after its initial release. p19
    \item Reusability: is reusable if it can be used to create a new product. p22
    \item Portability: if it can run in different environments. p23
    \item Understandability: how easy it is to understand requirements, design, implementation, and documentation. p24
    \item Interoperability, Productivity, Timeliness and Visibility: p30$-$33
\end{itemize}

\section{Softare Principles}
Lecture 5, 6
\begin{itemize}
    \item Rigour: An argument is valid if the conclusion is logical,and it has mathematics support. Use between human.
    \item Formality: A language with a formal syntax and a precise semantics. Use between machines. 
    Advantages: formality can look at all possible outcomes, and this can help to find anything is missed by written specs.
    Disadvantages: it takes a long time to learn it. The tools are not easy to use, and they are not complete. p12
    \item Separation of concerns: different concerns should be isolated and considered separately, 
    reduce a complex problem to a set of simpler problems, parallelization of effort. p18
    \item Modularity: is a complex system that is divided into smaller parts called modules. It enables separation of concerns
    \begin{itemize}
        \item Different parts of the system are considered separately
        \item The parts of the system are considered separately from their composition
        \item Good module design L6.P4
        \begin{itemize}
            \item High cohesion: The components of the module are closely related. p24
            \item Low coupling: The module does not strongly depend on other modules. low is good, but not zero coupling.
        \end{itemize}
        \item this allow modules be treated in two way:
        \begin{itemize}
            \item As a set of interchangeable parts
            \item As individuals
        \end{itemize}
    \end{itemize}
    \item Abstraction: is the process of focusing on what is important while ignoring what is irrelevant. Special case of 
    separation of concerns. L6.P6
    \item Make an Abstract Data Type Abstract: don’t say how it implemented, gave interface but not the implementation.
    \item Anticipation of change: is the principle that future change should be anticipated and planned for.
    Some technique to deal with change. L6.P10
    \begin{itemize}
        \item Configuration management
        \item Information hiding
        \item Documentation
    \end{itemize}
    \item Generality: is to use a more general solution to solve the problem. L6.P13
    \begin{itemize}
        \item Good1: increase reusability.
        \item Good2: general problem is easier to solve somtimes
        \item Bad1: less efficient
        \item Bad2: it is costly to have a general solution
        \item Use more abstraction, usually help increase generality.
    \end{itemize}
    \item Incrementality: solving problems by producing successively closer approximations to a solution. Get feedback, 
    and improve it accordingly.
\end{itemize}

\section{Module}
Lecture 7
\begin{itemize}
    \item Design for change: algorithm, safety standard. p5
    \item Product families: cars, phones
    \item Components of a module: a interface and a implementation(hide change in implementation). p13
    \item Information hiding: hidden from clients. Anticipating changes need to have information hiding. p16
    \item Example of Module p17
    \begin{itemize}
        \item Record: only have data
        \item Collection of related procedures(library): have behavior not state
        \item Abstract object: only have one instance
        \item Abstract data type: collection of abstract objects
        \item Generic modules: abstract description for a family of objects, like generic module of stack of integers, 
        strings, stacks.
    \end{itemize}
\end{itemize}

\section{Module Interface Specification}
Lecture 9
\begin{itemize}
    \item out and location function p7
    \item Why unit test: when merge module, we are confident problem occur when module interact with each other, 
    not module itself.
\end{itemize}

\section{Abstract Data Types}
Lecture 10
\begin{itemize}
    \item Read specification, semantics.
\end{itemize}

\section{Functional Programming}
Lecture 11, 12
\begin{itemize}
    \item Functional Programming: Computation is treated a the evaluation of mathematical functions
    \begin{itemize}
        \item No state, mutable data, only expression
        \item No side effects
    \end{itemize}
    \item List Comprehension L11 p14
    \item Map L12 p6
    \item Partial functions L12 p10
    \item Filter L12 p14
    \item Reduce p16
\end{itemize}

\section{Modules with Ext$.$ Interaction}
Lecture 13
\begin{itemize}
    \item Records
    \item Libraries
    \item Abstract Data types
    \item Abstract Objects
    \item Interfaces
    \item Generic Abstract Objects and Generic Abstract Data Types
    \item Inheritance
    \item External Interaction (Environment variable) p14
\end{itemize}

\section{Generic MIS}
Lecture 14
\begin{itemize}
    \item Fill Semantics out$:=?$ p6
    \item Abstract Objects and ADTs p18
    \item Abstract Objects use static method in Python
    \item Generic Modules $-$ Stack exmaple p15
    \item State Variable for Generic Stack p18
    \item State Invariant for Generic Stack p19
    \item Semantics for Generic Stack p20
\end{itemize}

\section{Object Oriented Design}
Lecture 15
\begin{itemize}
    \item Generic modules are implemented in Python via dynamic typing p7
    \item Inheritance p19
    \item UML Representation of Inheritance p25
\end{itemize}

\section{Module Interface Des}
Lecture 16
\begin{itemize}
    \item UML Bank Account Example p4
    \item UML Interface p5
    \item Class Diagram and MIS: Both MIS and Diagram show state variable, inputs, methods, arguments MIS has semantics, 
    UML doesn’t, only syntax. Some UML just show there is an association, but it doesn’t contain how it to be represented. 
    MIS included it. p6
    \item UML Associations p9
    \item UML Aggregation p11
    \item UML Packages: IS\_COMPONENT\_OF p12
    \item Assumptions and Exceptions p13
    \item Exception p14 
    \item Quality Criteria: Consistent, essential, general, minimal, high cohesion, low coupling, opaque.
    \item aovid exception p17
    \item essential p18
    \item setters and getters p19
    \item minimal p20
\end{itemize}

\section{Module Decomposition}
Lecture 17
\begin{itemize}
    \item minimal p6
    \item increase essential p9
    \item increase minimal 11
    \item The USES Relation p17
    \item DAG $-$ Directed Acyclic Graph p20
    \item use DAG in tree p22 
    \item Hierarchy p23
    \item static relation: user relationship is static, so it doesn’t dynamically change.
\end{itemize}

\section{Module Guide}
Lecture 18
\begin{itemize}
    \item Reduce example p4
    \item List comprehension p6
    \item Upside down tree relation p8
    \item Association and DAG p9
    \item Module Decomposition p10
    \item IS\_COMPONENT\_OF p12
    \item Information hiding p14
    \item Three Top Conceptual Modules: hardware hiding, software decision hiding, behavior hiding p18
    \item Criteria for a good secret p21
    \item Rational Design Process view, Graphically, binary matrix p25
    \item Module Guide Template p28
    \item Traceability Matrices p29
    \item Verification p30
\end{itemize}

\end {document}